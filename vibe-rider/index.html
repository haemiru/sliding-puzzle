<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Bike Rider üèçÔ∏è</title>
<style>
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;background:#000;touch-action:none}
canvas{display:block}
#retry{
  position:absolute;padding:14px 48px;font-size:18px;font-weight:700;
  border:1px solid rgba(255,255,255,0.15);border-radius:50px;cursor:pointer;display:none;
  background:linear-gradient(135deg,#ff6b35,#ff8c42);color:#fff;
  box-shadow:0 4px 20px rgba(255,107,53,0.4),0 2px 8px rgba(0,0,0,0.3);z-index:10;
  font-family:'Segoe UI',sans-serif;letter-spacing:2px;text-transform:uppercase;
  left:50%;transform:translateX(-50%);
  transition:all 0.2s ease;
}
#retry:hover{background:linear-gradient(135deg,#ff8c42,#ffab40);box-shadow:0 6px 28px rgba(255,140,66,0.5),0 2px 8px rgba(0,0,0,0.3);transform:translateX(-50%) translateY(-2px)}
</style>
</head>
<body>
<canvas id="c"></canvas>
<button id="retry">üîÑ Retry</button>
<script>
'use strict';
const canvas=document.getElementById('c'),ctx=canvas.getContext('2d'),retryBtn=document.getElementById('retry');
let W,H;

function resize(){
  W=window.innerWidth; H=window.innerHeight;
  canvas.width=W; canvas.height=H;
  canvas.style.width=W+'px'; canvas.style.height=H+'px';
}
window.addEventListener('resize',resize); resize();

// ‚ïê‚ïê‚ïê Audio ‚ïê‚ïê‚ïê
let audioCtx=null;
function ensureAudio(){
  if(!audioCtx) audioCtx=new(window.AudioContext||window.webkitAudioContext)();
  if(audioCtx.state==='suspended') audioCtx.resume();
}
function playNote(freq,dur,type,vol,delay){
  const t=audioCtx.currentTime+(delay||0);
  const o=audioCtx.createOscillator(), g=audioCtx.createGain();
  o.type=type||'sine'; o.frequency.setValueAtTime(freq,t);
  g.gain.setValueAtTime(vol||0.15,t); g.gain.exponentialRampToValueAtTime(0.001,t+dur);
  o.connect(g); g.connect(audioCtx.destination); o.start(t); o.stop(t+dur);
  return o;
}
function playNoise(dur,freq,vol,delay){
  const t=audioCtx.currentTime+(delay||0);
  const buf=audioCtx.createBuffer(1,audioCtx.sampleRate*dur,audioCtx.sampleRate);
  const d=buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,1.5);
  const src=audioCtx.createBufferSource(); src.buffer=buf;
  const f=audioCtx.createBiquadFilter(); f.type='bandpass'; f.frequency.value=freq||1000; f.Q.value=1;
  const g=audioCtx.createGain(); g.gain.setValueAtTime(vol||0.15,t); g.gain.exponentialRampToValueAtTime(0.001,t+dur);
  src.connect(f); f.connect(g); g.connect(audioCtx.destination); src.start(t);
}
function playCrashSound(){
  ensureAudio(); const t=audioCtx.currentTime;
  const buf=audioCtx.createBuffer(1,audioCtx.sampleRate*0.3,audioCtx.sampleRate);
  const d=buf.getChannelData(0);
  for(let i=0;i<d.length;i++) d[i]=(Math.random()*2-1)*Math.pow(1-i/d.length,2);
  const src=audioCtx.createBufferSource(); src.buffer=buf;
  const f=audioCtx.createBiquadFilter(); f.type='lowpass'; f.frequency.value=300;
  const g=audioCtx.createGain(); g.gain.setValueAtTime(0.5,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.3);
  src.connect(f); f.connect(g); g.connect(audioCtx.destination); src.start(t);
}

let engineOsc=null, engineGain=null;
function startEngineSound(){
  if(!audioCtx||engineOsc) return;
  engineOsc=audioCtx.createOscillator();
  engineGain=audioCtx.createGain();
  engineOsc.type='sawtooth';
  engineOsc.frequency.setValueAtTime(60,audioCtx.currentTime);
  engineGain.gain.setValueAtTime(0,audioCtx.currentTime);
  engineOsc.connect(engineGain);
  engineGain.connect(audioCtx.destination);
  engineOsc.start();
}
function updateEngineSound(speedRatio){
  if(!engineOsc||!audioCtx) return;
  const t=audioCtx.currentTime;
  engineOsc.frequency.setTargetAtTime(60+speedRatio*180,t,0.05);
  engineGain.gain.setTargetAtTime(speedRatio*0.08,t,0.05);
}
function stopEngineSound(){
  if(engineOsc){try{engineOsc.stop();}catch(e){}engineOsc=null;engineGain=null;}
}
function playLandingSound(){
  ensureAudio();
  playNoise(0.12,400,0.25);
  playNote(120,0.15,'sine',0.12);
}
function playFlipSound(){
  ensureAudio();
  playNote(880,0.1,'sine',0.12);
  playNote(1100,0.1,'sine',0.1,0.08);
  playNote(1320,0.15,'sine',0.12,0.16);
}

// ‚ïê‚ïê‚ïê Game Constants ‚ïê‚ïê‚ïê
const GRAVITY = 1100;
const TERRAIN_STEP = 5;
const MAX_SPEED = 1400;
const ENGINE_FORCE = 3200;
const BRAKE_FORCE = 2500;
const AIR_DRAG = 0.00015;
const GROUND_FRICTION = 0.12;
const WHEEL_BASE = 50;
const WHEEL_RADIUS = 16;
const ANGULAR_DAMPING = 0.988;
const LEAN_TORQUE_GROUND = 6;
const LEAN_TORQUE_AIR = 10;
const GAS_AIR_TORQUE = 10;
const BRAKE_AIR_TORQUE = 8;
const BOUNCE_DAMPING = 0.15;
const CRASH_HEAD_Y_THRESHOLD = 5;

// ‚ïê‚ïê‚ïê Game States ‚ïê‚ïê‚ïê
const STATE_TITLE = 0, STATE_PLAYING = 1, STATE_CRASHED = 2, STATE_GAMEOVER = 3;
let gameState = STATE_TITLE;

// ‚ïê‚ïê‚ïê Bike State ‚ïê‚ïê‚ïê
let bikeX=300, bikeY=0, bikeAngle=0;
let bikeVX=0, bikeVY=0, bikeAngVel=0;
let frontWheelGrounded=false, rearWheelGrounded=false;
let pedalPhase=0;
let distanceTraveled=0;
let flipCount=0, currentFlipAngle=0, wasAirborne=false;
let crashTimer=0;
let bestDistance=0;
let airTime=0;
let landingSafe=0;

// ‚ïê‚ïê‚ïê Camera ‚ïê‚ïê‚ïê
let camX=0, camY=0;

// ‚ïê‚ïê‚ïê Particles ‚ïê‚ïê‚ïê
let dustParticles=[];
let speedLines=[];
let crashParts=[];

// ‚ïê‚ïê‚ïê Title Stars ‚ïê‚ïê‚ïê
const titleStars=[];
for(let i=0;i<70;i++){
  titleStars.push({
    x:Math.random(), y:Math.random()*0.5,
    s:0.5+Math.random()*2,
    phase:Math.random()*Math.PI*2,
    speed:0.8+Math.random()*2
  });
}

// ‚ïê‚ïê‚ïê Terrain ‚ïê‚ïê‚ïê
let terrain=[];
const TERRAIN_AHEAD=3000;
const TERRAIN_BEHIND=600;
let terrainGenX=0;
let sectionIndex=0;

function getTerrainYAt(x){
  if(terrain.length<2) return H*0.6;
  if(x<=terrain[0].x) return terrain[0].y;
  if(x>=terrain[terrain.length-1].x) return terrain[terrain.length-1].y;
  let lo=0, hi=terrain.length-1;
  while(lo<hi-1){
    const mid=(lo+hi)>>1;
    if(terrain[mid].x<=x) lo=mid; else hi=mid;
  }
  const t=(x-terrain[lo].x)/(terrain[hi].x-terrain[lo].x);
  return terrain[lo].y+(terrain[hi].y-terrain[lo].y)*t;
}

function getTerrainNormalAt(x){
  const dx=TERRAIN_STEP*0.5;
  const y1=getTerrainYAt(x-dx);
  const y2=getTerrainYAt(x+dx);
  const tx=dx*2, ty=y2-y1;
  const len=Math.sqrt(tx*tx+ty*ty);
  return {x:ty/len, y:-tx/len}; // outward normal (90¬∞ CW rotation of tangent)
}

function getTerrainAngleAt(x){
  const dx=TERRAIN_STEP*0.5;
  const y1=getTerrainYAt(x-dx);
  const y2=getTerrainYAt(x+dx);
  return Math.atan2(y2-y1, dx*2);
}

// ‚ïê‚ïê‚ïê Terrain Generation ‚ïê‚ïê‚ïê
function generateTerrain(){
  while(terrain.length>2 && terrain[0].x < camX-TERRAIN_BEHIND){
    terrain.shift();
  }
  const targetX=camX+TERRAIN_AHEAD;
  if(terrainGenX===0){
    const baseY=H*0.65;
    for(let x=0;x<1200;x+=TERRAIN_STEP){
      terrain.push({x:x, y:baseY});
    }
    terrainGenX=1200;
  }
  while(terrainGenX<targetX){
    terrainGenX=addTerrainSection(terrainGenX);
  }
}

function addTerrainSection(startX){
  const difficulty=Math.min(distanceTraveled/6000, 1);
  const lastY=terrain.length>0?terrain[terrain.length-1].y:H*0.65;
  const baseY=H*0.65;

  const types=['flat','gentle_hills','steep_hill','ramp','big_jump','gap','bumpy','downhill','valley'];
  const weights=[
    0.20-difficulty*0.10,   // flat: common early
    0.20-difficulty*0.05,   // gentle_hills
    0.05+difficulty*0.08,   // steep_hill: rare early
    0.15+difficulty*0.10,   // ramp: fun jumps
    0.10+difficulty*0.10,   // big_jump
    0.03+difficulty*0.08,   // gap: rare early
    0.08+difficulty*0.04,   // bumpy
    0.10+difficulty*0.05,   // downhill: speed boost
    0.09                    // valley
  ];
  const totalW=weights.reduce((a,b)=>a+b,0);
  let r=Math.random()*totalW, chosen=0;
  for(let i=0;i<weights.length;i++){
    r-=weights[i];
    if(r<=0){chosen=i;break;}
  }
  const type=types[chosen];
  sectionIndex++;

  let endX=startX;

  // Smooth transition (smoothstep)
  const smoothTo=(targetY,length)=>{
    const steps=Math.ceil(length/TERRAIN_STEP);
    const sy=terrain.length>0?terrain[terrain.length-1].y:lastY;
    for(let i=1;i<=steps;i++){
      const t=i/steps;
      const ease=t*t*(3-2*t);
      const y=sy+(targetY-sy)*ease;
      endX=startX+i*TERRAIN_STEP;
      terrain.push({x:endX, y:y});
    }
    return endX;
  };

  // Linear ramp (constant slope ‚Äî crucial for real jumps)
  const linearTo=(targetY,length)=>{
    const steps=Math.ceil(length/TERRAIN_STEP);
    const sy=terrain.length>0?terrain[terrain.length-1].y:lastY;
    for(let i=1;i<=steps;i++){
      const t=i/steps;
      const y=sy+(targetY-sy)*t;
      endX=startX+i*TERRAIN_STEP;
      terrain.push({x:endX, y:y});
    }
    return endX;
  };

  const addFlat=(length, y)=>{
    const steps=Math.ceil(length/TERRAIN_STEP);
    const fy=y!==undefined?y:lastY;
    for(let i=1;i<=steps;i++){
      endX=startX+i*TERRAIN_STEP;
      terrain.push({x:endX, y:fy});
    }
    return endX;
  };

  // Sharp drop: terrain falls steeply (for jump launch)
  const sharpDrop=(dropY,length)=>{
    const steps=Math.ceil(length/TERRAIN_STEP);
    const sy=terrain.length>0?terrain[terrain.length-1].y:lastY;
    for(let i=1;i<=steps;i++){
      const t=i/steps;
      // Ease-in (accelerating drop): t^2
      const y=sy+(dropY-sy)*t*t;
      endX=startX+i*TERRAIN_STEP;
      terrain.push({x:endX, y:y});
    }
    return endX;
  };

  switch(type){
    case 'flat': {
      const len=250+Math.random()*350;
      endX=smoothTo(baseY, len*0.3);
      startX=endX;
      endX=addFlat(len*0.7, baseY);
      break;
    }
    case 'gentle_hills': {
      const numHills=2+Math.floor(Math.random()*3);
      const segLen=200+Math.random()*150;
      let cy=lastY;
      for(let h=0;h<numHills;h++){
        const amp=20+Math.random()*30+difficulty*25;
        const dir=h%2===0?-1:1;
        cy=Math.max(H*0.4, Math.min(H*0.75, cy+dir*amp));
        endX=smoothTo(cy, segLen);
        startX=endX;
      }
      break;
    }
    case 'steep_hill': {
      const height=40+Math.random()*40+difficulty*50;
      endX=smoothTo(lastY-height, 300+Math.random()*150);
      startX=endX;
      endX=addFlat(120+Math.random()*60, lastY-height);
      startX=endX;
      endX=smoothTo(baseY, 250+Math.random()*100);
      break;
    }
    case 'ramp': {
      const rampH=50+Math.random()*30+difficulty*40;
      // Flat approach for speed buildup
      endX=addFlat(120, lastY);
      startX=endX;
      // Linear up-ramp (constant slope = consistent launch angle)
      const rampLen=100+Math.random()*40;
      const rampTopY=lastY-rampH;
      endX=linearTo(rampTopY, rampLen);
      startX=endX;
      // Tiny lip (flat at top)
      endX=addFlat(10, rampTopY);
      startX=endX;
      // Sharp drop-off after lip ‚Äî terrain falls away fast so bike goes airborne
      const gapLen=180+Math.random()*120+difficulty*100;
      endX=sharpDrop(baseY+20, gapLen);
      startX=endX;
      // Landing zone
      endX=addFlat(250, baseY+20);
      startX=endX;
      endX=smoothTo(baseY, 100);
      break;
    }
    case 'big_jump': {
      // Aggressive ramp with long air gap
      const rampH=80+Math.random()*40+difficulty*50;
      // Long approach for speed
      endX=addFlat(150, lastY);
      startX=endX;
      // Steep linear ramp
      const rampTopY=lastY-rampH;
      endX=linearTo(rampTopY, 80+Math.random()*30);
      startX=endX;
      // Short lip
      endX=addFlat(8, rampTopY);
      startX=endX;
      // Immediate steep drop
      const dropTarget=baseY+40+difficulty*20;
      endX=sharpDrop(dropTarget, 100+Math.random()*50);
      startX=endX;
      // Long gap floor (far below)
      endX=addFlat(300+Math.random()*200+difficulty*80, dropTarget);
      startX=endX;
      // Up-ramp to landing (softer)
      endX=smoothTo(baseY, 200);
      break;
    }
    case 'gap': {
      endX=addFlat(80, lastY);
      startX=endX;
      const dropDepth=60+difficulty*60;
      const gapWidth=60+Math.random()*40+difficulty*40;
      const steps=Math.ceil(gapWidth/TERRAIN_STEP);
      for(let i=1;i<=steps;i++){
        const t=i/steps;
        const y=lastY+dropDepth*Math.sin(t*Math.PI);
        endX=startX+i*TERRAIN_STEP;
        terrain.push({x:endX, y:y});
      }
      startX=endX;
      endX=addFlat(100, lastY);
      break;
    }
    case 'bumpy': {
      const numBumps=4+Math.floor(Math.random()*4);
      let cy=lastY;
      for(let b=0;b<numBumps;b++){
        const amp=10+Math.random()*15+difficulty*12;
        const dir=b%2===0?-1:1;
        cy=Math.max(H*0.45, Math.min(H*0.75, cy+dir*amp));
        endX=smoothTo(cy, 40+Math.random()*40);
        startX=endX;
      }
      endX=smoothTo(baseY, 120);
      break;
    }
    case 'downhill': {
      const drop=50+Math.random()*40+difficulty*35;
      endX=smoothTo(lastY+drop, 350+Math.random()*200);
      startX=endX;
      endX=addFlat(120, lastY+drop);
      startX=endX;
      endX=smoothTo(baseY, 250);
      break;
    }
    case 'valley': {
      const depth=40+Math.random()*35+difficulty*30;
      endX=smoothTo(lastY+depth, 180);
      startX=endX;
      endX=addFlat(80, lastY+depth);
      startX=endX;
      endX=smoothTo(lastY-15, 250);
      startX=endX;
      endX=smoothTo(baseY, 120);
      break;
    }
  }
  return endX;
}

// ‚ïê‚ïê‚ïê Input ‚ïê‚ïê‚ïê
const keys={};
document.addEventListener('keydown',e=>{keys[e.key]=true;keys[e.code]=true;ensureAudio();e.preventDefault()});
document.addEventListener('keyup',e=>{keys[e.key]=false;keys[e.code]=false});

let touchActive=false;
let touchLeft=false, touchRight=false;
canvas.addEventListener('touchstart',e=>{
  e.preventDefault();ensureAudio();
  touchLeft=false;touchRight=false;
  for(let i=0;i<e.touches.length;i++){
    if(e.touches[i].clientX<W/2) touchLeft=true;
    else touchRight=true;
  }
  touchActive=true;
},{passive:false});
canvas.addEventListener('touchmove',e=>{
  e.preventDefault();
  touchLeft=false;touchRight=false;
  for(let i=0;i<e.touches.length;i++){
    if(e.touches[i].clientX<W/2) touchLeft=true;
    else touchRight=true;
  }
},{passive:false});
canvas.addEventListener('touchend',e=>{
  e.preventDefault();
  touchLeft=false;touchRight=false;
  for(let i=0;i<e.touches.length;i++){
    if(e.touches[i].clientX<W/2) touchLeft=true;
    else touchRight=true;
  }
  if(e.touches.length===0){touchActive=false;touchLeft=false;touchRight=false;}
},{passive:false});

function isAccel(){return keys['ArrowUp']||keys['w']||keys['W']||keys[' ']||keys['Space']||touchRight;}
function isBrake(){return keys['ArrowDown']||keys['s']||keys['S']||touchLeft;}
function isLeanBack(){return keys['ArrowLeft']||keys['a']||keys['A'];}
function isLeanForward(){return keys['ArrowRight']||keys['d']||keys['D'];}
// Touch lean is handled via gas/brake in air (see physics update)

// Detect touch device
let isTouchDevice=false;
canvas.addEventListener('touchstart',function detectTouch(){isTouchDevice=true;canvas.removeEventListener('touchstart',detectTouch);},{passive:true});

// ‚ïê‚ïê‚ïê Physics Update ‚ïê‚ïê‚ïê
function updatePhysics(dt){
  if(gameState!==STATE_PLAYING) return;

  const airborne=!frontWheelGrounded&&!rearWheelGrounded;
  const cosA=Math.cos(bikeAngle), sinA=Math.sin(bikeAngle);
  const halfWB=WHEEL_BASE/2;

  // Gravity ‚Äî always applies
  bikeVY+=GRAVITY*dt;

  // Engine / Brake ‚Äî air controls only after 0.15s airtime (ignore tiny bounces)
  const realAir=airborne&&airTime>0.15;
  if(realAir){
    // AIR: gas = lean forward (nose down), brake = lean back (nose up)
    if(isAccel()){
      bikeAngVel+=GAS_AIR_TORQUE*dt;
      pedalPhase+=dt*8;
    }
    if(isBrake()){
      bikeAngVel-=BRAKE_AIR_TORQUE*dt;
    }
  } else {
    // GROUND: gas = engine thrust, brake = slow down
    if(isAccel()){
      bikeVX+=cosA*ENGINE_FORCE*dt;
      bikeVY+=sinA*ENGINE_FORCE*dt;
      pedalPhase+=dt*12;
    }
    if(isBrake()){
      const spd=Math.sqrt(bikeVX*bikeVX+bikeVY*bikeVY);
      if(spd>1){
        bikeVX-=(bikeVX/spd)*BRAKE_FORCE*dt;
        bikeVY-=(bikeVY/spd)*BRAKE_FORCE*dt;
      }
    }
  }

  // Air drag
  const spd=Math.sqrt(bikeVX*bikeVX+bikeVY*bikeVY);
  if(spd>0){
    const drag=AIR_DRAG*spd*spd;
    bikeVX-=(bikeVX/spd)*drag*dt;
    bikeVY-=(bikeVY/spd)*drag*dt;
  }

  // Lean torque (‚Üê/‚Üí keys)
  if(isLeanBack()){
    bikeAngVel-=(realAir?LEAN_TORQUE_AIR:LEAN_TORQUE_GROUND)*dt;
  }
  if(isLeanForward()){
    bikeAngVel+=(realAir?LEAN_TORQUE_AIR:LEAN_TORQUE_GROUND)*dt;
  }

  // Angular damping + gravity torque
  // Use realAir (airTime>0.15s) so brief ground flickers don't break physics
  if(realAir){
    bikeAngVel*=Math.pow(ANGULAR_DAMPING,dt*60);
  } else {
    bikeAngVel*=Math.pow(0.5,dt);
    // Gravity torque only past tipping point (~23¬∞)
    let tilt=bikeAngle%(Math.PI*2);
    if(tilt>Math.PI) tilt-=Math.PI*2;
    if(tilt<-Math.PI) tilt+=Math.PI*2;
    if(Math.abs(tilt)>0.4){
      bikeAngVel+=Math.sin(bikeAngle)*GRAVITY*0.025*dt;
    }
  }

  // Apply velocity
  bikeX+=bikeVX*dt;
  bikeY+=bikeVY*dt;
  bikeAngle+=bikeAngVel*dt;

  // ‚îÄ‚îÄ‚îÄ Wheel-terrain contact (rigid body constraint) ‚îÄ‚îÄ‚îÄ
  frontWheelGrounded=false;
  rearWheelGrounded=false;

  const cosA2=Math.cos(bikeAngle), sinA2=Math.sin(bikeAngle);
  const rwx=bikeX-cosA2*halfWB;
  const fwx=bikeX+cosA2*halfWB;
  const rTerrainY=getTerrainYAt(rwx);
  const fTerrainY=getTerrainYAt(fwx);

  // Max allowed bikeY so each wheel stays above terrain
  const maxY_r=rTerrainY-WHEEL_RADIUS+sinA2*halfWB;
  const maxY_f=fTerrainY-WHEEL_RADIUS-sinA2*halfWB;
  const maxY=Math.min(maxY_r, maxY_f);

  if(bikeY>maxY){
    bikeY=maxY;

    // Determine which wheels are on ground
    const rwy2=bikeY-sinA2*halfWB;
    const fwy2=bikeY+sinA2*halfWB;
    if(rwy2+WHEEL_RADIUS>=rTerrainY-2) rearWheelGrounded=true;
    if(fwy2+WHEEL_RADIUS>=fTerrainY-2) frontWheelGrounded=true;

    // Single velocity correction at bike center (no per-wheel leveling)
    const n=getTerrainNormalAt(bikeX);
    const vDotN=bikeVX*n.x+bikeVY*n.y;
    if(vDotN<0){
      if(wasAirborne && vDotN<-80){
        playLandingSound();
        const wx=rearWheelGrounded?rwx:fwx;
        const wy=rearWheelGrounded?rTerrainY:fTerrainY;
        for(let i=0;i<8;i++){
          dustParticles.push({
            x:wx, y:wy,
            vx:(Math.random()-0.5)*120, vy:-Math.random()*100,
            life:0.5+Math.random()*0.3, maxLife:0.5+Math.random()*0.3,
            size:3+Math.random()*4
          });
        }
      }
      const bd=wasAirborne?0:BOUNCE_DAMPING;
      bikeVX-=n.x*vDotN*(1+bd);
      bikeVY-=n.y*vDotN*(1+bd);
    }

    // Friction
    if(!isAccel()){
      const n2=getTerrainNormalAt(bikeX);
      const tx=-n2.y, ty=n2.x;
      const vT=bikeVX*tx+bikeVY*ty;
      bikeVX-=tx*vT*GROUND_FRICTION*dt;
      bikeVY-=ty*vT*GROUND_FRICTION*dt;
    }
  }

  // Speed cap
  const curSpd=Math.sqrt(bikeVX*bikeVX+bikeVY*bikeVY);
  if(curSpd>MAX_SPEED){
    bikeVX*=MAX_SPEED/curSpd;
    bikeVY*=MAX_SPEED/curSpd;
  }

  // ‚îÄ‚îÄ‚îÄ Flip tracking ‚îÄ‚îÄ‚îÄ
  const nowAirborne=!frontWheelGrounded&&!rearWheelGrounded;
  if(nowAirborne){
    airTime+=dt;
    currentFlipAngle+=bikeAngVel*dt;
    if(Math.abs(currentFlipAngle)>=Math.PI*2){
      flipCount+=Math.floor(Math.abs(currentFlipAngle)/(Math.PI*2));
      currentFlipAngle=currentFlipAngle%(Math.PI*2);
      playFlipSound();
    }
  } else {
    // Just landed ‚Äî check angle AT this moment
    if(wasAirborne){
      const na=((bikeAngle%(Math.PI*2))+Math.PI*2)%(Math.PI*2);
      // Crash only if truly upside-down (>110¬∞ from upright)
      if(na>Math.PI*0.61 && na<Math.PI*1.39){
        triggerCrash();
        wasAirborne=nowAirborne;
        return;
      }
      // Good landing ‚Äî only stabilize after significant air time (flips/big jumps)
      if(airTime>0.3){
        bikeAngVel=0;
        bikeAngle=getTerrainAngleAt(bikeX);
        const terrainN=getTerrainNormalAt(bikeX);
        const vDot=bikeVX*terrainN.x+bikeVY*terrainN.y;
        if(vDot<0){
          bikeVX-=terrainN.x*vDot;
          bikeVY-=terrainN.y*vDot;
        }
        landingSafe=0.3;
      }
    }
    airTime=0;
    currentFlipAngle=0;
  }
  wasAirborne=nowAirborne;

  if(landingSafe>0) landingSafe-=dt;

  // ‚îÄ‚îÄ‚îÄ Crash detection: head hitting ground ‚îÄ‚îÄ‚îÄ
  // Skip briefly after a successful landing to prevent wobble deaths
  if(landingSafe<=0 && (rearWheelGrounded||frontWheelGrounded)){
    const hx=bikeX+sinA2*40;
    const hy=bikeY-cosA2*40;
    const headTerrainY=getTerrainYAt(hx);
    if(hy>headTerrainY-CRASH_HEAD_Y_THRESHOLD){
      triggerCrash();
      return;
    }
  }

  // Distance
  distanceTraveled=Math.max(distanceTraveled, (bikeX-300)*0.05);

  // Engine sound
  updateEngineSound(Math.min(1,curSpd/MAX_SPEED));

  // Dust particles when grounded
  if((rearWheelGrounded||frontWheelGrounded) && curSpd>80 && Math.random()<0.3){
    const wx=rearWheelGrounded?rwx:fwx;
    const wy=rearWheelGrounded?rTerrainY:fTerrainY;
    dustParticles.push({
      x:wx, y:wy,
      vx:-bikeVX*0.1+(Math.random()-0.5)*30, vy:-Math.random()*40,
      life:0.3+Math.random()*0.2, maxLife:0.3+Math.random()*0.2,
      size:2+Math.random()*3
    });
  }

  // Speed lines
  if(curSpd>400 && Math.random()<0.4){
    speedLines.push({
      x:camX+Math.random()*W, y:camY+Math.random()*H,
      len:20+Math.random()*30, life:0.15, maxLife:0.15
    });
  }

  generateTerrain();
}

function triggerCrash(){
  gameState=STATE_CRASHED;
  crashTimer=0;
  playCrashSound();
  stopEngineSound();
  for(let i=0;i<15;i++){
    crashParts.push({
      x:bikeX, y:bikeY,
      vx:(Math.random()-0.5)*300, vy:-Math.random()*400,
      life:1+Math.random()*0.5, maxLife:1+Math.random()*0.5,
      size:3+Math.random()*5,
      color:`hsl(${Math.random()*60},80%,${50+Math.random()*30}%)`
    });
  }
}

function updateParticles(dt){
  for(let i=dustParticles.length-1;i>=0;i--){
    const p=dustParticles[i];
    p.x+=p.vx*dt; p.y+=p.vy*dt;
    p.vy+=300*dt; p.life-=dt;
    if(p.life<=0) dustParticles.splice(i,1);
  }
  for(let i=speedLines.length-1;i>=0;i--){
    speedLines[i].life-=dt;
    if(speedLines[i].life<=0) speedLines.splice(i,1);
  }
  for(let i=crashParts.length-1;i>=0;i--){
    const p=crashParts[i];
    p.x+=p.vx*dt; p.y+=p.vy*dt;
    p.vy+=500*dt; p.life-=dt;
    if(p.life<=0) crashParts.splice(i,1);
  }
}

// ‚ïê‚ïê‚ïê Camera ‚ïê‚ïê‚ïê
function updateCamera(){
  const targetX=bikeX-W*0.3;
  const targetY=bikeY-H*0.4;
  camX+=(targetX-camX)*0.08;
  camY+=(targetY-camY)*0.06;
  const groundY=getTerrainYAt(bikeX);
  const maxCamY=groundY-H*0.3;
  if(camY>maxCamY) camY+=(maxCamY-camY)*0.12;
}

// ‚ïê‚ïê‚ïê Rendering ‚ïê‚ïê‚ïê
function drawParallaxBg(){
  const skyG=ctx.createLinearGradient(0,0,0,H*0.6);
  skyG.addColorStop(0,'#1a0533');
  skyG.addColorStop(0.35,'#3b1f6e');
  skyG.addColorStop(0.65,'#6a4c93');
  skyG.addColorStop(1,'#f0a060');
  ctx.fillStyle=skyG;ctx.fillRect(0,0,W,H);

  const sunX=W*0.75-camX*0.01;
  const sunY=H*0.18;
  const sunG=ctx.createRadialGradient(sunX,sunY,0,sunX,sunY,60);
  sunG.addColorStop(0,'rgba(255,230,120,1)');
  sunG.addColorStop(0.4,'rgba(255,180,80,0.6)');
  sunG.addColorStop(1,'rgba(255,120,30,0)');
  ctx.fillStyle=sunG;ctx.beginPath();ctx.arc(sunX,sunY,60,0,Math.PI*2);ctx.fill();

  const p1=-camX*0.05;
  ctx.fillStyle='#2d1b4e';ctx.beginPath();ctx.moveTo(0,H*0.55);
  for(let x=0;x<=W;x+=20){
    const wx=x+p1;
    ctx.lineTo(x,H*0.48-(Math.sin(wx*0.003)*40+Math.sin(wx*0.007)*25+Math.sin(wx*0.0012)*50));
  }
  ctx.lineTo(W,H*0.6);ctx.lineTo(0,H*0.6);ctx.fill();

  const p2=-camX*0.15;
  ctx.fillStyle='#3d2960';ctx.beginPath();ctx.moveTo(0,H*0.58);
  for(let x=0;x<=W;x+=15){
    const wx=x+p2;
    ctx.lineTo(x,H*0.52-(Math.sin(wx*0.005+200)*30+Math.sin(wx*0.009)*20));
  }
  ctx.lineTo(W,H*0.65);ctx.lineTo(0,H*0.65);ctx.fill();

  const p3=-camX*0.25;
  ctx.fillStyle='#1a1030';
  const bldgs=[40,75,55,95,60,42,88,68,48,82,62,100,38,72,92,52,78];
  let bx=(p3%55)-55;
  for(let i=0;bx<W+60;i++){
    const bw=20+(i*7)%18;
    const bh=bldgs[i%bldgs.length]*0.7;
    ctx.fillRect(bx,H*0.58-bh,bw,bh+20);
    ctx.fillStyle='rgba(255,200,80,0.2)';
    for(let wy=H*0.58-bh+6;wy<H*0.58;wy+=8){
      for(let wx=bx+3;wx<bx+bw-3;wx+=5){
        if(((wx*7+wy*13+i*3)%10)>5) ctx.fillRect(wx,wy,2,3);
      }
    }
    ctx.fillStyle='#1a1030';
    bx+=bw+3+(i*3)%8;
  }
}

function drawTerrain(){
  if(terrain.length<2) return;
  ctx.save();
  ctx.translate(-camX,-camY);

  const startX=camX-50;
  const endX=camX+W+50;

  ctx.beginPath();
  let started=false;
  for(let i=0;i<terrain.length;i++){
    const p=terrain[i];
    if(p.x<startX) continue;
    if(p.x>endX){if(started){ctx.lineTo(p.x,p.y);}break;}
    if(!started){
      const prevI=Math.max(0,i-1);
      ctx.moveTo(terrain[prevI].x,terrain[prevI].y);
      started=true;
    }
    ctx.lineTo(p.x,p.y);
  }
  ctx.lineTo(endX+100, camY+H+100);
  ctx.lineTo(startX-100, camY+H+100);
  ctx.closePath();

  const grassG=ctx.createLinearGradient(0,camY+H*0.5,0,camY+H);
  grassG.addColorStop(0,'#2d8a2d');
  grassG.addColorStop(0.1,'#1e6b1e');
  grassG.addColorStop(0.4,'#5a3a1a');
  grassG.addColorStop(1,'#3d2810');
  ctx.fillStyle=grassG;
  ctx.fill();

  ctx.beginPath();
  started=false;
  for(let i=0;i<terrain.length;i++){
    const p=terrain[i];
    if(p.x<startX) continue;
    if(p.x>endX) break;
    if(!started){ctx.moveTo(terrain[Math.max(0,i-1)].x,terrain[Math.max(0,i-1)].y);started=true;}
    ctx.lineTo(p.x,p.y);
  }
  ctx.strokeStyle='#1a5c1a';ctx.lineWidth=3;ctx.stroke();

  ctx.strokeStyle='#3aa33a';ctx.lineWidth=1.5;
  for(let x=Math.floor(startX/40)*40;x<endX;x+=40){
    const ty=getTerrainYAt(x);
    if(ty>camY-20&&ty<camY+H+20){
      ctx.beginPath();ctx.moveTo(x,ty);ctx.lineTo(x-3,ty-8);ctx.stroke();
      ctx.beginPath();ctx.moveTo(x+5,ty);ctx.lineTo(x+7,ty-6);ctx.stroke();
      ctx.beginPath();ctx.moveTo(x+10,ty);ctx.lineTo(x+8,ty-7);ctx.stroke();
    }
  }
  ctx.restore();
}

function drawWheel(x,y,r,rot){
  ctx.strokeStyle='#222';ctx.lineWidth=4;
  ctx.beginPath();ctx.arc(x,y,r,0,Math.PI*2);ctx.stroke();
  ctx.strokeStyle='#888';ctx.lineWidth=1.5;
  ctx.beginPath();ctx.arc(x,y,r-3,0,Math.PI*2);ctx.stroke();
  ctx.strokeStyle='#aaa';ctx.lineWidth=0.8;
  for(let a=0;a<Math.PI*2;a+=Math.PI/4){
    const sa=a+rot;
    ctx.beginPath();ctx.moveTo(x,y);
    ctx.lineTo(x+Math.cos(sa)*(r-3), y+Math.sin(sa)*(r-3));ctx.stroke();
  }
  ctx.fillStyle='#666';
  ctx.beginPath();ctx.arc(x,y,3,0,Math.PI*2);ctx.fill();
}

function drawBike(){
  ctx.save();
  ctx.translate(bikeX-camX, bikeY-camY);
  ctx.rotate(bikeAngle);

  const halfWB=WHEEL_BASE/2;
  const wheelRot=bikeVX*0.02*(Date.now()*0.001);

  drawWheel(-halfWB, 0, WHEEL_RADIUS, wheelRot);
  drawWheel(halfWB, 0, WHEEL_RADIUS, wheelRot);

  // Frame
  ctx.strokeStyle='#e03030';ctx.lineWidth=3;ctx.lineCap='round';
  ctx.beginPath();ctx.moveTo(-halfWB,0);ctx.lineTo(-5,-20);ctx.lineTo(halfWB,0);ctx.stroke();
  ctx.beginPath();ctx.moveTo(-5,-20);ctx.lineTo(5,-18);ctx.stroke();
  ctx.beginPath();ctx.moveTo(-5,-20);ctx.lineTo(-halfWB+5,0);ctx.stroke();
  ctx.strokeStyle='#888';ctx.lineWidth=2;
  ctx.beginPath();ctx.moveTo(halfWB-8,-15);ctx.lineTo(halfWB,0);ctx.stroke();
  ctx.strokeStyle='#555';ctx.lineWidth=2.5;
  ctx.beginPath();ctx.moveTo(halfWB-12,-18);ctx.lineTo(halfWB-4,-22);ctx.stroke();

  // Seat
  ctx.fillStyle='#333';
  ctx.beginPath();ctx.ellipse(-5,-22,8,3,0,0,Math.PI*2);ctx.fill();

  // Legs
  ctx.strokeStyle='#d4a574';ctx.lineWidth=4;ctx.lineCap='round';
  const lFX=-halfWB+5+Math.cos(pedalPhase)*8;
  const lFY=8+Math.sin(pedalPhase)*5;
  ctx.beginPath();ctx.moveTo(-8,-12);ctx.quadraticCurveTo(-12,0,lFX,lFY);ctx.stroke();
  const rFX=-halfWB+5+Math.cos(pedalPhase+Math.PI)*8;
  const rFY=8+Math.sin(pedalPhase+Math.PI)*5;
  ctx.beginPath();ctx.moveTo(-2,-12);ctx.quadraticCurveTo(-6,0,rFX,rFY);ctx.stroke();
  ctx.fillStyle='#fff';
  ctx.beginPath();ctx.ellipse(lFX,lFY,4,2.5,0,0,Math.PI*2);ctx.fill();
  ctx.beginPath();ctx.ellipse(rFX,rFY,4,2.5,0,0,Math.PI*2);ctx.fill();

  // Torso
  ctx.fillStyle='#2196F3';
  ctx.beginPath();ctx.moveTo(-12,-14);ctx.lineTo(2,-14);ctx.lineTo(5,-30);ctx.lineTo(-10,-30);ctx.closePath();ctx.fill();
  ctx.fillStyle='#1565C0';ctx.fillRect(-5,-28,3,14);

  // Arms
  ctx.strokeStyle='#d4a574';ctx.lineWidth=3.5;ctx.lineCap='round';
  ctx.beginPath();ctx.moveTo(0,-28);ctx.quadraticCurveTo(10,-26,halfWB-8,-18);ctx.stroke();
  ctx.beginPath();ctx.moveTo(-3,-28);ctx.quadraticCurveTo(8,-24,halfWB-10,-17);ctx.stroke();

  // Helmet
  ctx.fillStyle='#ff5722';
  ctx.beginPath();ctx.ellipse(-2,-36,8,7,0,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='rgba(255,255,255,0.25)';
  ctx.beginPath();ctx.ellipse(-5,-39,4,3,0,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='rgba(100,200,255,0.5)';
  ctx.beginPath();ctx.roundRect(2,-38,6,4,2);ctx.fill();
  ctx.fillStyle='#d4a574';ctx.fillRect(-4,-30,5,3);

  ctx.restore();
}

function drawCrashedBike(){
  ctx.save();
  ctx.translate(bikeX-camX, bikeY-camY);
  const t=Math.min(crashTimer,1.5);
  ctx.translate(0, -Math.sin(t*2)*30*(1-t/1.5));
  ctx.rotate(bikeAngle+t*8);
  ctx.globalAlpha=Math.max(0.3, 1-t*0.4);
  const halfWB=WHEEL_BASE/2;
  ctx.strokeStyle='#222';ctx.lineWidth=3;
  ctx.beginPath();ctx.arc(-halfWB,0,WHEEL_RADIUS,0,Math.PI*2);ctx.stroke();
  ctx.beginPath();ctx.arc(halfWB,0,WHEEL_RADIUS,0,Math.PI*2);ctx.stroke();
  ctx.strokeStyle='#a02020';ctx.lineWidth=2;
  ctx.beginPath();ctx.moveTo(-halfWB,0);ctx.quadraticCurveTo(0,-15,halfWB,5);ctx.stroke();
  ctx.fillStyle='#d4a574';ctx.beginPath();ctx.ellipse(5,-20,6,6,0,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#ff5722';ctx.beginPath();ctx.ellipse(5,-24,7,5,0,0,Math.PI*2);ctx.fill();
  ctx.fillStyle='#2196F3';ctx.fillRect(-5,-15,15,12);
  ctx.restore();
}

function drawDustParticles(){
  ctx.save();
  for(const p of dustParticles){
    ctx.globalAlpha=(p.life/p.maxLife)*0.6;
    ctx.fillStyle='#c8b090';
    ctx.beginPath();ctx.arc(p.x-camX,p.y-camY,p.size,0,Math.PI*2);ctx.fill();
  }
  ctx.restore();
}

function drawSpeedLines(){
  ctx.save();
  for(const s of speedLines){
    ctx.globalAlpha=(s.life/s.maxLife)*0.3;
    ctx.strokeStyle='#fff';ctx.lineWidth=1;
    ctx.beginPath();ctx.moveTo(s.x-camX,s.y-camY);ctx.lineTo(s.x-camX-s.len,s.y-camY);ctx.stroke();
  }
  ctx.restore();
}

function drawCrashParts(){
  ctx.save();
  for(const p of crashParts){
    ctx.globalAlpha=p.life/p.maxLife;
    ctx.fillStyle=p.color;
    ctx.beginPath();ctx.arc(p.x-camX,p.y-camY,p.size,0,Math.PI*2);ctx.fill();
  }
  ctx.restore();
}

function drawAirIndicator(){
  if(!wasAirborne || gameState!==STATE_PLAYING) return;
  ctx.save();
  ctx.textAlign='center';
  const bx=bikeX-camX, by=bikeY-camY-60;
  const at=airTime.toFixed(1);
  ctx.font=`bold ${Math.max(16,W*0.022)}px 'Segoe UI',sans-serif`;
  ctx.strokeStyle='rgba(0,0,0,0.6)';ctx.lineWidth=3;
  ctx.strokeText(`AIR ${at}s`,bx,by);
  ctx.fillStyle='#ffd54f';
  ctx.fillText(`AIR ${at}s`,bx,by);
  if(Math.abs(currentFlipAngle)>Math.PI*0.5){
    const flipPct=Math.floor((Math.abs(currentFlipAngle)/(Math.PI*2))*100);
    ctx.font=`bold ${Math.max(14,W*0.018)}px 'Segoe UI',sans-serif`;
    ctx.fillStyle='#ff5722';
    ctx.strokeText(`FLIP ${flipPct}%`,bx,by-22);
    ctx.fillText(`FLIP ${flipPct}%`,bx,by-22);
  }
  ctx.restore();
}

function drawHUD(){
  const dist=Math.max(0,Math.floor(distanceTraveled));
  const spd=Math.floor(Math.sqrt(bikeVX*bikeVX+bikeVY*bikeVY)*0.36);

  const fs=Math.max(12,W*0.015);
  ctx.save();
  ctx.textBaseline='middle';

  // Individual stat pills
  const pillH=fs*2.2;
  const pillY=10;
  const gap=8;
  const pills=[
    {label:`${dist}m`,tag:'DIST',color:'rgba(255,107,53,0.15)',border:'rgba(255,107,53,0.3)',tagColor:'#ff8a50'},
    {label:`${spd} km/h`,tag:'SPD',color:'rgba(76,175,80,0.15)',border:'rgba(76,175,80,0.3)',tagColor:'#66bb6a'},
    {label:`${flipCount}`,tag:'FLIP',color:'rgba(156,39,176,0.15)',border:'rgba(156,39,176,0.3)',tagColor:'#ba68c8'},
  ];

  const tagFs=Math.max(9,fs*0.7);
  ctx.font=`700 ${fs}px 'Segoe UI',sans-serif`;
  let totalW=0;
  const measured=pills.map(p=>{
    ctx.font=`700 ${tagFs}px 'Segoe UI',sans-serif`;
    const tagW=ctx.measureText(p.tag).width;
    ctx.font=`700 ${fs}px 'Segoe UI',sans-serif`;
    const valW=ctx.measureText(p.label).width;
    const tw=tagW+valW+24;
    totalW+=tw;
    return tw;
  });
  totalW+=(pills.length-1)*gap;
  let px=W/2-totalW/2;

  pills.forEach((p,i)=>{
    const pw=measured[i];
    // Background
    ctx.fillStyle='rgba(0,0,0,0.45)';
    ctx.beginPath();ctx.roundRect(px,pillY,pw,pillH,pillH/2);ctx.fill();
    ctx.fillStyle=p.color;
    ctx.beginPath();ctx.roundRect(px,pillY,pw,pillH,pillH/2);ctx.fill();
    ctx.strokeStyle=p.border;
    ctx.lineWidth=1;
    ctx.beginPath();ctx.roundRect(px,pillY,pw,pillH,pillH/2);ctx.stroke();
    // Tag + Value
    ctx.textAlign='center';
    ctx.font=`700 ${tagFs}px 'Segoe UI',sans-serif`;
    ctx.fillStyle=p.tagColor;
    const tagW=ctx.measureText(p.tag).width;
    ctx.font=`700 ${fs}px 'Segoe UI',sans-serif`;
    const valW=ctx.measureText(p.label).width;
    const contentW=tagW+6+valW;
    const startX=px+(pw-contentW)/2;
    ctx.font=`700 ${tagFs}px 'Segoe UI',sans-serif`;
    ctx.textAlign='left';
    ctx.fillText(p.tag,startX,pillY+pillH/2);
    ctx.font=`700 ${fs}px 'Segoe UI',sans-serif`;
    ctx.fillStyle='#fff';
    ctx.fillText(p.label,startX+tagW+6,pillY+pillH/2);
    px+=pw+gap;
  });

  // Speed bar
  const barW=totalW, barH=3;
  const barX=W/2-barW/2, barY2=pillY+pillH+5;
  ctx.fillStyle='rgba(0,0,0,0.25)';
  ctx.beginPath();ctx.roundRect(barX,barY2,barW,barH,2);ctx.fill();
  const sR=Math.min(1,Math.sqrt(bikeVX*bikeVX+bikeVY*bikeVY)/MAX_SPEED);
  const bG=ctx.createLinearGradient(barX,0,barX+barW,0);
  bG.addColorStop(0,'#4caf50');bG.addColorStop(0.6,'#ff9800');bG.addColorStop(1,'#f44336');
  ctx.fillStyle=bG;
  if(sR>0.01){ctx.beginPath();ctx.roundRect(barX,barY2,barW*sR,barH,2);ctx.fill();}
  ctx.restore();
}

function drawTitleScreen(){
  drawParallaxBg();
  const t=Date.now()*0.001;
  ctx.save();
  ctx.textAlign='center';
  ctx.textBaseline='middle';

  // ‚îÄ‚îÄ Twinkling stars ‚îÄ‚îÄ
  for(const s of titleStars){
    const a=0.3+0.7*(0.5+0.5*Math.sin(t*s.speed+s.phase));
    ctx.globalAlpha=a;
    ctx.fillStyle='#fff';
    ctx.beginPath();ctx.arc(s.x*W,s.y*H,s.s,0,Math.PI*2);ctx.fill();
  }
  ctx.globalAlpha=1;

  // ‚îÄ‚îÄ Title with glow + animated gradient ‚îÄ‚îÄ
  const ts=Math.max(52,W*0.085);
  ctx.font=`900 ${ts}px 'Segoe UI',Impact,sans-serif`;
  const titleY=H*0.2;

  // Outer glow
  ctx.shadowColor='rgba(255,100,30,0.7)';
  ctx.shadowBlur=35;
  ctx.strokeStyle='#000';
  ctx.lineWidth=ts*0.07;
  ctx.lineJoin='round';
  ctx.strokeText('BIKE RIDER',W/2,titleY);

  // Animated gradient shine
  const shinePos=0.5+0.5*Math.sin(t*0.8);
  const tg=ctx.createLinearGradient(W*0.2,titleY-ts*0.5,W*0.8,titleY+ts*0.5);
  tg.addColorStop(0,'#ff6b35');
  tg.addColorStop(Math.max(0,shinePos-0.12),'#ff8c42');
  tg.addColorStop(shinePos,'#ffe082');
  tg.addColorStop(Math.min(1,shinePos+0.12),'#ff8c42');
  tg.addColorStop(1,'#ff6b35');
  ctx.fillStyle=tg;
  ctx.fillText('BIKE RIDER',W/2,titleY);
  ctx.shadowBlur=0;

  // ‚îÄ‚îÄ Subtitle with decorative lines + diamonds ‚îÄ‚îÄ
  const ss=Math.max(14,W*0.02);
  const subY=titleY+ts*0.6;
  ctx.font=`600 ${ss}px 'Segoe UI',sans-serif`;
  const subText='PHYSICS-BASED BIKE RACE';
  const subTW=ctx.measureText(subText).width;
  const dLineL=Math.min(50,W*0.06);

  ctx.strokeStyle='rgba(255,213,79,0.4)';
  ctx.lineWidth=1;
  ctx.beginPath();
  ctx.moveTo(W/2-subTW/2-dLineL-16,subY);
  ctx.lineTo(W/2-subTW/2-8,subY);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(W/2+subTW/2+8,subY);
  ctx.lineTo(W/2+subTW/2+dLineL+16,subY);
  ctx.stroke();

  // Diamond accents
  ctx.fillStyle='#ffd54f';
  [W/2-subTW/2-dLineL-20, W/2+subTW/2+dLineL+20].forEach(dx=>{
    ctx.save();ctx.translate(dx,subY);ctx.rotate(Math.PI/4);
    ctx.fillRect(-2.5,-2.5,5,5);ctx.restore();
  });

  ctx.fillStyle='#ffd54f';
  ctx.fillText(subText,W/2,subY);

  // ‚îÄ‚îÄ Controls Card ‚îÄ‚îÄ
  const cardW=Math.min(440,W*0.88);
  const cardH=Math.min(180,H*0.25);
  const cardX=W/2-cardW/2;
  const cardY=H*0.40;

  // Card background gradient
  const cardBg=ctx.createLinearGradient(cardX,cardY,cardX,cardY+cardH);
  cardBg.addColorStop(0,'rgba(15,8,30,0.82)');
  cardBg.addColorStop(1,'rgba(25,15,45,0.78)');
  ctx.fillStyle=cardBg;
  ctx.beginPath();ctx.roundRect(cardX,cardY,cardW,cardH,14);ctx.fill();

  // Card border
  ctx.strokeStyle='rgba(255,140,66,0.25)';
  ctx.lineWidth=1;
  ctx.beginPath();ctx.roundRect(cardX,cardY,cardW,cardH,14);ctx.stroke();

  // Header
  const hdrY=cardY+30;
  ctx.font=`700 ${Math.max(11,W*0.015)}px 'Segoe UI',sans-serif`;
  ctx.fillStyle='#ff8a50';
  ctx.fillText('CONTROLS',W/2,cardY+16);
  ctx.strokeStyle='rgba(255,140,66,0.2)';
  ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(cardX+20,hdrY);ctx.lineTo(cardX+cardW-20,hdrY);ctx.stroke();

  // Control rows
  const cs=Math.max(11,W*0.014);
  const rowH=(cardH-42)/4;
  const rows=[
    {keys:'W / ‚¨Ü / Space',desc:'Gas (Ground) / Flip Forward (Air)',color:'#a5d6a7'},
    {keys:'S / ‚¨á',desc:'Brake (Ground) / Flip Back (Air)',color:'#ef9a9a'},
    {keys:'A / ‚¨Ö   D / ‚û°',desc:'Lean Back / Lean Forward',color:'#90caf9'},
  ];

  rows.forEach((r,i)=>{
    const ry=hdrY+10+i*rowH+rowH/2;
    // Key badge
    ctx.font=`700 ${cs}px 'Segoe UI',sans-serif`;
    const kw=ctx.measureText(r.keys).width+18;
    const kx=cardX+20;
    ctx.fillStyle='rgba(255,255,255,0.07)';
    ctx.beginPath();ctx.roundRect(kx,ry-cs*0.7,kw,cs*1.4,5);ctx.fill();
    ctx.strokeStyle='rgba(255,255,255,0.1)';
    ctx.beginPath();ctx.roundRect(kx,ry-cs*0.7,kw,cs*1.4,5);ctx.stroke();
    ctx.fillStyle=r.color;
    ctx.fillText(r.keys,kx+kw/2,ry);

    // Description
    ctx.textAlign='left';
    ctx.font=`${cs}px 'Segoe UI',sans-serif`;
    ctx.fillStyle='rgba(255,255,255,0.8)';
    ctx.fillText(r.desc,kx+kw+14,ry);
    ctx.textAlign='center';
  });

  // Touch row
  const touchRY=hdrY+10+3*rowH+rowH/2;
  ctx.fillStyle='rgba(100,180,255,0.08)';
  ctx.beginPath();ctx.roundRect(cardX+20,touchRY-cs*0.7,cardW-40,cs*1.4,5);ctx.fill();
  ctx.font=`${cs}px 'Segoe UI',sans-serif`;
  ctx.fillStyle='rgba(150,210,255,0.85)';
  ctx.fillText('üì±  Touch:  Left = Brake / Back   ‚Ä¢   Right = Gas / Forward',W/2,touchRY);

  // ‚îÄ‚îÄ Warning tip ‚îÄ‚îÄ
  const tipY=cardY+cardH+Math.max(16,H*0.025);
  ctx.font=`600 ${Math.max(13,W*0.017)}px 'Segoe UI',sans-serif`;
  ctx.fillStyle='#ff8a65';
  ctx.fillText('‚ö†  Land on your wheels or CRASH!',W/2,tipY);

  // ‚îÄ‚îÄ Start prompt with glow pulse ‚îÄ‚îÄ
  const stY=H*0.86;
  const stS=Math.max(20,W*0.032);
  const pulse=0.5+0.5*Math.sin(t*4);

  ctx.shadowColor=`rgba(255,255,255,${pulse*0.4})`;
  ctx.shadowBlur=20;
  ctx.font=`700 ${stS}px 'Segoe UI',sans-serif`;
  ctx.fillStyle=`rgba(255,255,255,${0.65+pulse*0.35})`;
  ctx.fillText('‚ñ∂  Press any key to start',W/2,stY);
  ctx.shadowBlur=0;

  // ‚îÄ‚îÄ Best score badge ‚îÄ‚îÄ
  if(bestDistance>0){
    const bdY=stY+stS*1.3;
    const bdS=Math.max(14,W*0.019);
    ctx.font=`700 ${bdS}px 'Segoe UI',sans-serif`;
    const bdText=`BEST: ${bestDistance}m`;
    const bdW=ctx.measureText(bdText).width+36;

    // Pill background
    ctx.fillStyle='rgba(255,193,7,0.15)';
    ctx.beginPath();ctx.roundRect(W/2-bdW/2,bdY-bdS*0.7,bdW,bdS*1.5,bdS);ctx.fill();
    ctx.strokeStyle='rgba(255,193,7,0.4)';
    ctx.lineWidth=1;
    ctx.beginPath();ctx.roundRect(W/2-bdW/2,bdY-bdS*0.7,bdW,bdS*1.5,bdS);ctx.stroke();

    ctx.fillStyle='#ffd54f';
    ctx.fillText('üèÜ '+bdText,W/2,bdY);
  }

  ctx.restore();
}

function drawGameOver(){
  ctx.save();
  ctx.textAlign='center';
  ctx.textBaseline='middle';

  // Full-screen dim overlay
  ctx.fillStyle='rgba(0,0,0,0.5)';
  ctx.fillRect(0,0,W,H);

  // Sizes
  const goS=Math.max(28,Math.min(W*0.05,42));
  const statS=Math.max(14,Math.min(W*0.02,20));
  const dist=Math.max(0,Math.floor(distanceTraveled));
  const isRecord=dist>=bestDistance&&dist>0;

  // Calculate card height from contents
  const pad=20;
  const titleH=goS*1.6;
  const statBlockH=statS*5.5;
  const recordH=statS*2;
  const cardH=pad+titleH+statBlockH+recordH+pad;
  const cardW=Math.min(340,W*0.75);
  const cardX=W/2-cardW/2;
  const cardY=H/2-cardH/2-30;

  // Card background
  const cardBg=ctx.createLinearGradient(cardX,cardY,cardX,cardY+cardH);
  cardBg.addColorStop(0,'rgba(40,10,10,0.93)');
  cardBg.addColorStop(1,'rgba(20,5,15,0.9)');
  ctx.fillStyle=cardBg;
  ctx.beginPath();ctx.roundRect(cardX,cardY,cardW,cardH,16);ctx.fill();
  ctx.strokeStyle='rgba(255,68,68,0.3)';
  ctx.lineWidth=1;
  ctx.beginPath();ctx.roundRect(cardX,cardY,cardW,cardH,16);ctx.stroke();

  // ‚îÄ‚îÄ GAME OVER title (inside card) ‚îÄ‚îÄ
  let cy=cardY+pad+titleH*0.4;
  ctx.font=`900 ${goS}px 'Segoe UI',Impact,sans-serif`;
  ctx.shadowColor='rgba(255,50,50,0.5)';
  ctx.shadowBlur=20;
  ctx.strokeStyle='#000';ctx.lineWidth=goS*0.06;ctx.lineJoin='round';
  ctx.strokeText('GAME OVER',W/2,cy);
  ctx.fillStyle='#ff4444';
  ctx.fillText('GAME OVER',W/2,cy);
  ctx.shadowBlur=0;

  // Separator
  cy+=titleH*0.45;
  ctx.strokeStyle='rgba(255,68,68,0.2)';
  ctx.lineWidth=1;
  ctx.beginPath();ctx.moveTo(cardX+30,cy);ctx.lineTo(cardX+cardW-30,cy);ctx.stroke();

  // ‚îÄ‚îÄ Stats: side by side ‚îÄ‚îÄ
  cy+=statS*1.8;
  const colW=cardW*0.4;

  // Distance column (left)
  ctx.font=`${statS*0.75}px 'Segoe UI',sans-serif`;
  ctx.fillStyle='rgba(255,255,255,0.45)';
  ctx.fillText('DISTANCE',W/2-colW/2,cy);
  ctx.font=`700 ${statS*1.5}px 'Segoe UI',sans-serif`;
  ctx.fillStyle='#fff';
  ctx.fillText(`${dist}m`,W/2-colW/2,cy+statS*1.6);

  // Flips column (right)
  ctx.font=`${statS*0.75}px 'Segoe UI',sans-serif`;
  ctx.fillStyle='rgba(255,255,255,0.45)';
  ctx.fillText('FLIPS',W/2+colW/2,cy);
  ctx.font=`700 ${statS*1.5}px 'Segoe UI',sans-serif`;
  ctx.fillStyle='#fff';
  ctx.fillText(`${flipCount}`,W/2+colW/2,cy+statS*1.6);

  // ‚îÄ‚îÄ Record / Best badge ‚îÄ‚îÄ
  cy+=statS*3.8;
  if(isRecord){
    const recS=Math.max(14,W*0.02);
    ctx.font=`700 ${recS}px 'Segoe UI',sans-serif`;
    const recText='NEW RECORD!';
    const recW=ctx.measureText('üèÜ '+recText).width+28;
    ctx.fillStyle='rgba(255,193,7,0.18)';
    ctx.beginPath();ctx.roundRect(W/2-recW/2,cy-recS*0.7,recW,recS*1.4,recS);ctx.fill();
    ctx.strokeStyle='rgba(255,193,7,0.4)';
    ctx.beginPath();ctx.roundRect(W/2-recW/2,cy-recS*0.7,recW,recS*1.4,recS);ctx.stroke();
    ctx.fillStyle='#ffd54f';
    ctx.fillText('üèÜ '+recText,W/2,cy);
  } else if(bestDistance>0){
    ctx.font=`${Math.max(13,W*0.017)}px 'Segoe UI',sans-serif`;
    ctx.fillStyle='rgba(255,255,255,0.35)';
    ctx.fillText(`Best: ${bestDistance}m`,W/2,cy);
  }

  // Retry button position
  retryBtn.style.display='block';
  retryBtn.style.top=(cardY+cardH+18)+'px';
  ctx.restore();
}

function drawControlsHint(){
  if(distanceTraveled>5||gameState!==STATE_PLAYING) return;
  ctx.save();
  ctx.globalAlpha=Math.max(0,1-distanceTraveled/5);
  const hintW=320,hintH=50,hintX=W/2-hintW/2,hintY=H*0.72;
  ctx.fillStyle='rgba(0,0,0,0.5)';
  ctx.beginPath();ctx.roundRect(hintX,hintY,hintW,hintH,8);ctx.fill();
  ctx.font='14px "Segoe UI",sans-serif';ctx.fillStyle='#fff';ctx.textAlign='center';
  ctx.fillText('‚¨Ü Gas / Flip Fwd    ‚¨á Brake / Flip Back    Land on wheels!',W/2,hintY+30);
  ctx.restore();
}

function drawTouchControls(){
  if(!isTouchDevice||gameState!==STATE_PLAYING) return;
  ctx.save();
  ctx.textAlign='center';
  ctx.textBaseline='middle';

  const btnW=Math.min(130,W*0.28);
  const btnH=Math.min(70,H*0.1);
  const margin=16;
  const btnY=H-btnH-margin;
  const radius=16;

  const airborne=!frontWheelGrounded&&!rearWheelGrounded;

  // ‚îÄ‚îÄ Left button: BRAKE ‚îÄ‚îÄ
  const lx=margin;
  const lPressed=touchLeft;
  ctx.globalAlpha=lPressed?0.55:0.25;

  // Background
  ctx.fillStyle=lPressed?'rgba(239,83,80,0.7)':'rgba(0,0,0,0.5)';
  ctx.beginPath();ctx.roundRect(lx,btnY,btnW,btnH,radius);ctx.fill();
  ctx.strokeStyle=lPressed?'rgba(255,120,120,0.8)':'rgba(255,255,255,0.2)';
  ctx.lineWidth=1.5;
  ctx.beginPath();ctx.roundRect(lx,btnY,btnW,btnH,radius);ctx.stroke();

  // Icon + label
  const iconS=Math.max(22,btnH*0.35);
  const labelS=Math.max(10,btnH*0.16);
  ctx.fillStyle='#fff';
  ctx.font=`${iconS}px 'Segoe UI',sans-serif`;
  ctx.fillText('‚¨á',lx+btnW/2,btnY+btnH*0.38);
  ctx.font=`700 ${labelS}px 'Segoe UI',sans-serif`;
  ctx.fillText(airborne?'FLIP BACK':'BRAKE',lx+btnW/2,btnY+btnH*0.75);

  // ‚îÄ‚îÄ Right button: GAS ‚îÄ‚îÄ
  const rx=W-btnW-margin;
  const rPressed=touchRight;
  ctx.globalAlpha=rPressed?0.55:0.25;

  ctx.fillStyle=rPressed?'rgba(76,175,80,0.7)':'rgba(0,0,0,0.5)';
  ctx.beginPath();ctx.roundRect(rx,btnY,btnW,btnH,radius);ctx.fill();
  ctx.strokeStyle=rPressed?'rgba(120,255,120,0.8)':'rgba(255,255,255,0.2)';
  ctx.lineWidth=1.5;
  ctx.beginPath();ctx.roundRect(rx,btnY,btnW,btnH,radius);ctx.stroke();

  ctx.fillStyle='#fff';
  ctx.font=`${iconS}px 'Segoe UI',sans-serif`;
  ctx.fillText('‚¨Ü',rx+btnW/2,btnY+btnH*0.38);
  ctx.font=`700 ${labelS}px 'Segoe UI',sans-serif`;
  ctx.fillText(airborne?'FLIP FWD':'GAS',rx+btnW/2,btnY+btnH*0.75);

  ctx.globalAlpha=1;
  ctx.restore();
}

// ‚ïê‚ïê‚ïê Main Render ‚ïê‚ïê‚ïê
function render(){
  ctx.clearRect(0,0,W,H);
  if(gameState===STATE_TITLE){drawTitleScreen();return;}

  drawParallaxBg();
  drawTerrain();
  drawDustParticles();
  drawSpeedLines();

  if(gameState===STATE_CRASHED||gameState===STATE_GAMEOVER){
    drawCrashedBike();
    drawCrashParts();
  } else {
    drawBike();
  }

  drawAirIndicator();
  drawHUD();
  drawControlsHint();
  drawTouchControls();

  if(gameState===STATE_GAMEOVER) drawGameOver();
}

// ‚ïê‚ïê‚ïê Game Loop ‚ïê‚ïê‚ïê
let lastTs=0;
function loop(ts){
  const dt=Math.min((ts-lastTs)/1000,0.033);
  lastTs=ts;

  if(gameState===STATE_TITLE){
    if(Object.values(keys).some(v=>v)||touchActive){
      gameState=STATE_PLAYING;
      startEngineSound();
    }
  }

  if(gameState===STATE_PLAYING){
    updatePhysics(dt);
    updateCamera();
    updateParticles(dt);
  }

  if(gameState===STATE_CRASHED){
    crashTimer+=dt;
    bikeVY+=GRAVITY*dt*0.3;
    bikeY+=bikeVY*dt*0.3;
    bikeAngVel*=0.98;
    bikeAngle+=bikeAngVel*dt;
    // Keep bike on terrain surface
    const groundY=getTerrainYAt(bikeX)-WHEEL_RADIUS;
    if(bikeY>groundY){
      bikeY=groundY;
      bikeVY=0;
    }
    updateCamera();
    updateParticles(dt);
    if(crashTimer>=2.0){
      gameState=STATE_GAMEOVER;
      bestDistance=Math.max(bestDistance, Math.floor(distanceTraveled));
    }
  }

  render();
  requestAnimationFrame(loop);
}

function reset(){
  bikeX=300;bikeY=0;bikeAngle=0;
  bikeVX=0;bikeVY=0;bikeAngVel=0;
  frontWheelGrounded=false;rearWheelGrounded=false;
  pedalPhase=0;distanceTraveled=0;
  flipCount=0;currentFlipAngle=0;wasAirborne=false;
  crashTimer=0;airTime=0;landingSafe=0;
  camX=0;camY=0;
  dustParticles=[];speedLines=[];crashParts=[];
  terrain=[];terrainGenX=0;sectionIndex=0;
  gameState=STATE_TITLE;
  retryBtn.style.display='none';
  stopEngineSound();
  generateTerrain();
  bikeY=getTerrainYAt(bikeX)-WHEEL_RADIUS-WHEEL_BASE*0.2;
  camX=bikeX-W*0.3;
  camY=bikeY-H*0.45;
}
retryBtn.addEventListener('click',reset);

if(!ctx.roundRect){
  CanvasRenderingContext2D.prototype.roundRect=function(x,y,w,h,r){
    if(typeof r==='number') r={tl:r,tr:r,br:r,bl:r};
    this.moveTo(x+r.tl,y);this.lineTo(x+w-r.tr,y);this.quadraticCurveTo(x+w,y,x+w,y+r.tr);
    this.lineTo(x+w,y+h-r.br);this.quadraticCurveTo(x+w,y+h,x+w-r.br,y+h);
    this.lineTo(x+r.bl,y+h);this.quadraticCurveTo(x,y+h,x,y+h-r.bl);
    this.lineTo(x,y+r.tl);this.quadraticCurveTo(x,y,x+r.tl,y);
  };
}

reset();
requestAnimationFrame(loop);
</script>
</body>
</html>
